// Generated by LiveScript 1.3.1
(function(){
  define(['jquery', 'react', 'prelude-ls', 'backbone', 'gridster', 'io'], function($, React, Prelude, Backbone, Gridster, io){
    var ref$, map, filter, slice, lines, any, fold, Str, i, div, tr, td, span, kbd, button, ul, li, a, h1, h2, h3, input, form, table, th, thead, tbody, label, nav, p, ruby, rt, dboard;
    ref$ = require('prelude-ls'), map = ref$.map, filter = ref$.filter, slice = ref$.slice, lines = ref$.lines, any = ref$.any, fold = ref$.fold, Str = ref$.Str;
    ref$ = React.DOM, i = ref$.i, div = ref$.div, tr = ref$.tr, td = ref$.td, span = ref$.span, kbd = ref$.kbd, button = ref$.button, ul = ref$.ul, li = ref$.li, a = ref$.a, h1 = ref$.h1, h2 = ref$.h2, h3 = ref$.h3, input = ref$.input, form = ref$.form, table = ref$.table, th = ref$.th, tr = ref$.tr, td = ref$.td, thead = ref$.thead, tbody = ref$.tbody, label = ref$.label, nav = ref$.nav, p = ref$.p, ruby = ref$.ruby, rt = ref$.rt;
    dboard = {};
    dboard.SourceModel = Backbone.Model.extend({
      idAttribute: "name",
      defaults: {
        name: null,
        value: 42,
        unit: null,
        last_update: null,
        timeout: 60 * 3,
        outdated: false,
        error: null
      },
      url: function(){
        return 'http://' + document.domain + ':' + location.port + "/source/" + this.get('name');
      },
      initialize: function(attr, options){
        console.log("Init source (" + this.get('name') + ")");
        this.checkOutDatedTimeout = null;
        this.socket = io.connect(this.url());
        this.socket.on('update', this.newDataPushed.bind(this));
        this.fetch({
          success: this.checkOutDated.bind(this)
        });
        return this;
      },
      newDataPushed: function(data){
        this.set(data);
        return this.checkOutDated();
      },
      checkOutDated: function(){
        var lastUpdate, timeout;
        clearTimeout(this.checkOutDatedTimeout);
        lastUpdate = moment(this.get('last_update'));
        if (lastUpdate.isValid()) {
          timeout = this.get('timeout');
          if (moment().diff(lastUpdate, 'second') > timeout) {
            this.set('outdated', true);
            this.set('error', lastUpdate.fromNow(true));
          } else {
            if (this.get('outdated')) {
              this.set('error', false);
            }
            this.set('outdated', false);
            this.checkOutDatedTimeout = setTimeout(this.checkOutDated.bind(this), Math.min(timeout, 15) * 1000);
          }
        }
        return this;
      }
    });
    dboard.SourcesCollection = Backbone.Collection.extend({
      url: function(){
        return '/source';
      },
      model: dboard.SourceModel,
      parse: function(data){
        return data.sources;
      }
    });
    dboard.AbstractGridDashboard = {
      widget_w: 145,
      widget_h: 145,
      margin_w: 10,
      margin_h: 10,
      componentDidMount: function(){
        var w, h, mw, mh;
        w = this.widget_w;
        h = this.widget_h;
        mw = this.margin_w;
        mh = this.margin_h;
        this.grid = $(this.refs.maingrid.getDOMNode()).gridster({
          'widget_margins': [mw, mh],
          'widget_base_dimensions': [w, h],
          'max_cols': 8,
          'min_cols': 8
        }).data('gridster');
        this.grid.disable();
        return $(this.refs.maingrid.getDOMNode()).find("li").each(function(i, li){
          var sizex, sizey, widgetW, widgetH;
          sizex = $(li).attr("data-sizex");
          sizey = $(li).attr("data-sizey");
          widgetW = w * sizex + 2 * mw * (sizex - 1);
          widgetH = h * sizey + 2 * mh * (sizey - 1);
          return $(li).first().children().first().width(widgetW).height(widgetH);
        });
      }
    };
    dboard.WaitDashboard = React.createClass({
      render: function(){
        return div({
          className: "ui active dimmer"
        }, div({
          className: "ui loader"
        }));
      }
    });
    dboard.DBoardApp = React.createClass({
      url: function(){
        return 'http://' + document.domain + ':' + location.port + "/dash";
      },
      dashboards: {
        wait: dboard.WaitDashboard({})
      },
      sources: new dboard.SourcesCollection([]),
      getInitialState: function(){
        return {
          dash: 'wait'
        };
      },
      componentWillMount: function(){
        console.log("<dboard app mounted>");
        console.log(this.props);
        this.sources.fetch({
          success: this.createAppDashboards.bind(this)
        });
        this.socket = io.connect(this.url());
        this.socket.on('update', this.dashUpdated.bind(this));
        if (this.props.debug) {
          window.sources = this.sources;
          return window.dashboards = this.dashboards;
        }
      },
      createAppDashboards: function(){
        var dash;
        dash = this.props.dboardBuilder(this.sources, this.dashboards);
        return this.setState({
          dash: dash
        });
      },
      componentWillUnmount: function(){
        return this.socket.off('update', this.dashUpdated.bind(this));
      },
      dashUpdated: function(data){
        var new_dash;
        new_dash = data.dash;
        if (new_dash in this.dashboards) {
          this.setState({
            dash: new_dash
          });
        } else {
          console.log("ERROR: server ask an unexisting dash ('" + new_dash + "')");
        }
      },
      render: function(){
        return this.dashboards[this.state.dash];
      }
    });
    return dboard;
  });
}).call(this);
